#!/usr/bin/env tclsh
##
## Multiplatform Tcl/Tk GUI for configuring and launching QEMU virtual machines.
## The tool manages simple per-VM configuration files and can generate or run
## QEMU command lines based on the options described in readme.md.
##

package require Tcl 8.6
if {[catch {package require Tk} err]} {
    puts "Tk is required to run this GUI: $err"
    exit 1
}

namespace eval ::qemu {
    variable appVersion "0.1"
    variable storageDir [file normalize [file join [pwd] "vms"]]
    variable vmList {}
    variable selectedVm ""
    variable jobLogs {}
    variable logViewerText ""
    variable logFilterStatus "all"
    variable logFilterCode ""
    variable logPlaybackAfter ""
    variable logPlaybackQueue {}
    variable logPlaybackIndex 0
    variable qemuPathOverrides {
        x86_64 ""
        i386 ""
        aarch64 ""
        arm ""
    }
}

proc ::qemu::ensureStorage {} {
    variable storageDir
    if {![file exists $storageDir]} {
        file mkdir $storageDir
    }
}

proc ::qemu::sanitizeId {name} {
    set base [string map {{ } _} [string tolower $name]]
    regsub -all {[^a-zA-Z0-9_.-]} $base "_" base
    if {$base eq ""} { set base "vm" }
    set id "${base}_[clock format [clock seconds] -format %Y%m%d%H%M%S]"
    return $id
}

proc ::qemu::loadVmFile {path} {
    set config {}
    if {[catch {source $path} err]} {
        tk_messageBox -icon error -type ok -title "Chyba při načítání" \
            -message "Konfigurace $path nelze načíst:\n$err"
        return ""
    }
    if {![info exists config]} {
        return ""
    }
    return $config
}

proc ::qemu::loadAll {} {
    variable storageDir
    variable vmList
    set vmList {}
    foreach f [lsort [glob -nocomplain -types f [file join $storageDir "*.tcl"]]] {
        set cfg [loadVmFile $f]
        if {$cfg eq ""} { continue }
        set id [file rootname [file tail $f]]
        lappend vmList [list $id $cfg]
    }
}

proc ::qemu::saveVm {id config} {
    variable storageDir
    set path [file join $storageDir "${id}.tcl"]
    set fh [open $path w]
    puts $fh "# Autogenerated VM config"
    puts $fh "set config [list $config]"
    close $fh
}

proc ::qemu::renderVmSummary {cfg} {
    set name [dict get $cfg name]
    set arch [dict get $cfg arch]
    set mem [dict get $cfg memory]
    set cpus [dict get $cfg cpus]
    set machine [dict get $cfg machine]
    set accel [dict get $cfg accel]
    set display [dict get $cfg display]
    return "$name — $arch, ${cpus} CPU, ${mem} MB, machine $machine, accel $accel, display $display"
}

proc ::qemu::getDefaultConfig {} {
    return [dict create \
        name "New VM" \
        arch "x86_64" \
        machine "pc" \
        memory 2048 \
        cpus 2 \
        cpu_model "host" \
        accel "kvm" \
        boot_order "cd" \
        firmware "" \
        iso "" \
        vga "std" \
        display "sdl" \
        snapshot_mode 0 \
        extra_args "" \
        disks {} \
        net {} \
    ]
}

proc ::qemu::addDiskToConfig {cfg diskDict} {
    set disks [dict get $cfg disks]
    lappend disks $diskDict
    dict set cfg disks $disks
    return $cfg
}

proc ::qemu::addNetToConfig {cfg netDict} {
    set nets [dict get $cfg net]
    lappend nets $netDict
    dict set cfg net $nets
    return $cfg
}

proc ::qemu::buildQemuBinary {arch} {
    variable qemuPathOverrides
    set override [dict get $qemuPathOverrides $arch]
    if {$override ne ""} {
        return $override
    }
    switch -- $arch {
        x86_64 { return "qemu-system-x86_64" }
        i386 { return "qemu-system-i386" }
        aarch64 { return "qemu-system-aarch64" }
        arm { return "qemu-system-arm" }
        default { return "qemu-system-$arch" }
    }
}

proc ::qemu::buildCommand {cfg} {
    set arch [dict get $cfg arch]
    set cmd [list [buildQemuBinary $arch]]
    dict with cfg {
        if {$name ne ""} { lappend cmd -name $name }
        if {$machine ne ""} { lappend cmd -machine $machine }
        if {$accel ne ""} { lappend cmd -accel $accel }
        if {$cpu_model ne ""} { lappend cmd -cpu $cpu_model }
        if {$cpus ne ""} { lappend cmd -smp $cpus }
        if {$memory ne ""} { lappend cmd -m $memory }
        if {$boot_order ne ""} { lappend cmd -boot "order=$boot_order" }
        if {$firmware ne ""} { lappend cmd -bios $firmware }
        if {$snapshot_mode} { lappend cmd -snapshot }
        if {$vga ne ""} { lappend cmd -vga $vga }
        if {$display ne ""} { lappend cmd -display $display }
    }
    foreach disk [dict get $cfg disks] {
        dict with disk {
            if {$media eq "cdrom"} {
                lappend cmd -drive "file=$file,format=$format,if=$if,media=cdrom"
            } else {
                set readonlyFlag ""
                if {$readonly} { set readonlyFlag ",snapshot=on" }
                lappend cmd -drive "file=$file,format=$format,if=$if,media=disk$readonlyFlag"
            }
            if {$boot} {
                # crude boot order hint: place bootable CD before disks
            }
        }
    }
    set iso [dict get $cfg iso]
    if {$iso ne ""} {
        lappend cmd -cdrom $iso
    }
    foreach net [dict get $cfg net] {
        dict with net {
            set nic "type=$type"
            if {$model ne ""} { append nic ",model=$model" }
            if {$hostfwd ne ""} { append nic ",hostfwd=$hostfwd" }
            if {$br ne ""} { append nic ",br=$br" }
            if {$tap ne ""} { append nic ",ifname=$tap" }
            if {$mac ne ""} { append nic ",mac=$mac" }
            lappend cmd -nic $nic
        }
    }
    set extra [dict get $cfg extra_args]
    if {$extra ne ""} {
        foreach token $extra { lappend cmd $token }
    }
    return $cmd
}

proc ::qemu::startVm {cfg} {
    set cmd [buildCommand $cfg]
    set commandStr [join $cmd " "]
    set res [tk_messageBox -type yesno -icon question -title "Spustit VM" \
        -message "Spustit následující příkaz?\n$commandStr"]
    if {$res ne "yes"} { return }
    if {[catch {eval exec {*}$cmd &} err]} {
        tk_messageBox -icon error -type ok -title "Spuštění selhalo" \
            -message "Příkaz se nepodařilo spustit:\n$err"
    }
}

proc ::qemu::showCommand {cfg} {
    set cmd [buildCommand $cfg]
    set win [toplevel .cmd]
    wm title $win "Vygenerovaný příkaz"
    text $win.t -wrap word -width 80 -height 8
    $win.t insert end [join $cmd " "]
    $win.t configure -state disabled
    pack $win.t -fill both -expand 1
}

proc ::qemu::openVmForm {mode {id ""} {cfg ""}} {
    if {$cfg eq ""} {
        set cfg [getDefaultConfig]
    }
    set varName "::qemu::form_[string map {. _} [clock clicks]]"

    set win [toplevel .vmform]
    wm title $win [expr {$mode eq "edit" ? "Upravit VM" : "Nový VM"}]
    grid columnconfigure $win 0 -weight 1

    set nb [ttk::notebook $win.nb]
    grid $nb -row 0 -column 0 -sticky news -padx 6 -pady 6

    # Základní karta
    set general [ttk::frame $nb.general]
    set growCols {1}
    set row 0
    foreach {label key} {
        "Název" name
        "Architektura" arch
        "Machine" machine
        "RAM (MB)" memory
        "CPU (počet)" cpus
        "Model CPU" cpu_model
        "Akcelerace" accel
        "Firmware/BIOS" firmware
        "Boot order" boot_order
        "ISO (CD/DVD)" iso
    } {
        ttk::label $general.l$row -text $label
        ttk::entry $general.e$row -textvariable ${varName}($key)
        grid $general.l$row -row $row -column 0 -sticky w -padx 4 -pady 2
        grid $general.e$row -row $row -column 1 -sticky we -padx 4 -pady 2
        incr row
    }
    ttk::checkbutton $general.snapshot -text "Spustit v režimu snapshot (-snapshot)" \
        -variable ${varName}(snapshot_mode)
    grid $general.snapshot -row $row -column 0 -columnspan 2 -sticky w -padx 4 -pady 2
    grid columnconfigure $general 1 -weight 1

    # Úložiště
    set storage [ttk::frame $nb.storage]
    ttk::label $storage.lbl -text "Disky a optická média"
    listbox $storage.list -height 6 -exportselection 0
    ttk::frame $storage.btns
    ttk::button $storage.btns.add -text "Přidat" -command [list ::qemu::addDiskDialog $storage $varName]
    ttk::button $storage.btns.del -text "Odebrat" -command [list ::qemu::removeSelectedDisk $storage $varName]
    pack $storage.btns.add $storage.btns.del -side top -padx 3 -pady 2
    grid $storage.lbl -row 0 -column 0 -sticky w -padx 4 -pady 2
    grid $storage.list -row 1 -column 0 -sticky news -padx 4 -pady 2
    grid $storage.btns -row 1 -column 1 -sticky ns -padx 4 -pady 2
    grid rowconfigure $storage 1 -weight 1
    grid columnconfigure $storage 0 -weight 1

    # Síť
    set network [ttk::frame $nb.network]
    ttk::label $network.lbl -text "Síťová rozhraní"
    listbox $network.list -height 5 -exportselection 0
    ttk::frame $network.btns
    ttk::button $network.btns.add -text "Přidat" -command [list ::qemu::addNetDialog $network $varName]
    ttk::button $network.btns.del -text "Odebrat" -command [list ::qemu::removeSelectedNet $network $varName]
    pack $network.btns.add $network.btns.del -side top -padx 3 -pady 2
    grid $network.lbl -row 0 -column 0 -sticky w -padx 4 -pady 2
    grid $network.list -row 1 -column 0 -sticky news -padx 4 -pady 2
    grid $network.btns -row 1 -column 1 -sticky ns -padx 4 -pady 2
    grid rowconfigure $network 1 -weight 1
    grid columnconfigure $network 0 -weight 1

    # Zobrazení
    set display [ttk::frame $nb.display]
    set row 0
    foreach {label key} {
        "VGA" vga
        "Display backend" display
    } {
        ttk::label $display.l$row -text $label
        ttk::entry $display.e$row -textvariable ${varName}($key)
        grid $display.l$row -row $row -column 0 -sticky w -padx 4 -pady 2
        grid $display.e$row -row $row -column 1 -sticky we -padx 4 -pady 2
        incr row
    }
    grid columnconfigure $display 1 -weight 1

    # Pokročilé
    set advanced [ttk::frame $nb.adv]
    ttk::label $advanced.extraL -text "Dodatečné parametry (oddělené mezerou)"
    ttk::entry $advanced.extraE -textvariable ${varName}(extra_args)
    grid $advanced.extraL -row 0 -column 0 -sticky w -padx 4 -pady 2
    grid $advanced.extraE -row 1 -column 0 -sticky we -padx 4 -pady 2
    grid columnconfigure $advanced 0 -weight 1

    $nb add $general -text "Obecné"
    $nb add $storage -text "Úložiště"
    $nb add $network -text "Síť"
    $nb add $display -text "Zobrazení"
    $nb add $advanced -text "Pokročilé"

    ttk::frame $win.actions
    ttk::button $win.actions.ok -text "Uložit" -command [list ::qemu::saveVmFromForm $win $mode $id $varName]
    ttk::button $win.actions.cancel -text "Zavřít" -command [list destroy $win]
    pack $win.actions.ok $win.actions.cancel -side left -padx 4 -pady 4
    grid $win.actions -row 1 -column 0 -sticky e -padx 8 -pady 6

    # Populate entries with cfg dict via array
    array set $varName $cfg
    if {![info exists ${varName}(disks)]} { set ${varName}(disks) {} }
    if {![info exists ${varName}(net)]} { set ${varName}(net) {} }
    ::qemu::refreshDiskList $storage $varName
    ::qemu::refreshNetList $network $varName

    grid rowconfigure $win 0 -weight 1
    grid columnconfigure $win 0 -weight 1
}

proc ::qemu::addDiskDialog {parent cfgVar} {
    set win [toplevel $parent.diskDialog]
    wm title $win "Přidat disk"
    set row 0
    foreach {label key default} {
        "Soubor" file ""
        "Formát" format "qcow2"
        "Rozhraní" if "virtio"
        "Typ média (disk/cdrom)" media "disk"
        "Bootovací (1/0)" boot 0
        "Pouze čtení (1/0)" readonly 0
    } {
        ttk::label $win.l$row -text $label
        ttk::entry $win.e$row -textvariable disk($key)
        grid $win.l$row -row $row -column 0 -sticky w -padx 4 -pady 2
        grid $win.e$row -row $row -column 1 -sticky we -padx 4 -pady 2
        incr row
    }
    ttk::frame $win.actions
    ttk::button $win.actions.ok -text "Přidat" -command [list ::qemu::confirmAddDisk $win $parent $cfgVar]
    ttk::button $win.actions.cancel -text "Zrušit" -command [list destroy $win]
    pack $win.actions.ok $win.actions.cancel -side left -padx 4 -pady 4
    grid $win.actions -row $row -column 0 -columnspan 2
    grid columnconfigure $win 1 -weight 1
}

proc ::qemu::confirmAddDisk {win parent cfgVar} {
    upvar $cfgVar cfg
    upvar $win::disk disk
    if {![info exists disk(file)] || $disk(file) eq ""} {
        tk_messageBox -icon warning -type ok -title "Chybí soubor" \
            -message "Zadejte cestu k souboru disku."
        return
    }
    set diskDict [dict create \
        file $disk(file) \
        format [expr {[info exists disk(format)] ? $disk(format) : "qcow2"}] \
        if [expr {[info exists disk(if)] ? $disk(if) : "virtio"}] \
        media [expr {[info exists disk(media)] ? $disk(media) : "disk"}] \
        boot [expr {[info exists disk(boot)] ? $disk(boot) : 0}] \
        readonly [expr {[info exists disk(readonly)] ? $disk(readonly) : 0}] \
    ]
    set disks $cfg(disks)
    lappend disks $diskDict
    set cfg(disks) $disks
    ::qemu::refreshDiskList $parent $cfgVar
    destroy $win
}

proc ::qemu::refreshDiskList {parent cfgVar} {
    upvar $cfgVar cfg
    $parent.disks delete 0 end
    foreach disk $cfg(disks) {
        dict with disk {
            $parent.disks insert end "$media: $file ($format, $if) [boot:$boot ro:$readonly]"
        }
    }
}

proc ::qemu::removeSelectedDisk {parent cfgVar} {
    upvar $cfgVar cfg
    set sel [$parent.disks curselection]
    if {$sel eq ""} { return }
    set disks $cfg(disks)
    set keep {}
    set i 0
    foreach disk $disks {
        if {[lsearch -exact $sel $i] == -1} {
            lappend keep $disk
        }
        incr i
    }
    set cfg(disks) $keep
    ::qemu::refreshDiskList $parent $cfgVar
}

proc ::qemu::addNetDialog {parent cfgVar} {
    set win [toplevel $parent.netDialog]
    wm title $win "Přidat síť"
    set row 0
    foreach {label key default} {
        "Typ (user/bridge/tap/none)" type "user"
        "Model" model "virtio-net-pci"
        "Hostfwd (např. tcp::2222-:22)" hostfwd ""
        "Bridge jméno" br ""
        "TAP jméno" tap ""
        "MAC adresa" mac ""
    } {
        ttk::label $win.l$row -text $label
        ttk::entry $win.e$row -textvariable net($key)
        grid $win.l$row -row $row -column 0 -sticky w -padx 4 -pady 2
        grid $win.e$row -row $row -column 1 -sticky we -padx 4 -pady 2
        incr row
    }
    ttk::frame $win.actions
    ttk::button $win.actions.ok -text "Přidat" -command [list ::qemu::confirmAddNet $win $parent $cfgVar]
    ttk::button $win.actions.cancel -text "Zrušit" -command [list destroy $win]
    pack $win.actions.ok $win.actions.cancel -side left -padx 4 -pady 4
    grid $win.actions -row $row -column 0 -columnspan 2
    grid columnconfigure $win 1 -weight 1
}

proc ::qemu::confirmAddNet {win parent cfgVar} {
    upvar $cfgVar cfg
    upvar $win::net net
    set netDict [dict create \
        type [expr {[info exists net(type)] ? $net(type) : "user"}] \
        model [expr {[info exists net(model)] ? $net(model) : "virtio-net-pci"}] \
        hostfwd [expr {[info exists net(hostfwd)] ? $net(hostfwd) : ""}] \
        br [expr {[info exists net(br)] ? $net(br) : ""}] \
        tap [expr {[info exists net(tap)] ? $net(tap) : ""}] \
        mac [expr {[info exists net(mac)] ? $net(mac) : ""}] \
    ]
    set nets $cfg(net)
    lappend nets $netDict
    set cfg(net) $nets
    ::qemu::refreshNetList $parent $cfgVar
    destroy $win
}

proc ::qemu::refreshNetList {parent cfgVar} {
    upvar $cfgVar cfg
    $parent.nets delete 0 end
    foreach net $cfg(net) {
        dict with net {
            $parent.nets insert end "$type/$model hostfwd:$hostfwd br:$br tap:$tap mac:$mac"
        }
    }
}

proc ::qemu::removeSelectedNet {parent cfgVar} {
    upvar $cfgVar cfg
    set sel [$parent.nets curselection]
    if {$sel eq ""} { return }
    set nets $cfg(net)
    set keep {}
    set i 0
    foreach net $nets {
        if {[lsearch -exact $sel $i] == -1} {
            lappend keep $net
        }
        incr i
    }
    set cfg(net) $keep
    ::qemu::refreshNetList $parent $cfgVar
}

proc ::qemu::saveVmFromForm {win mode id cfgVar} {
    upvar $cfgVar cfg
    set configDict [dict create]
    foreach key {
        name arch machine memory cpus cpu_model accel firmware boot_order iso
        vga display snapshot_mode extra_args
    } {
        if {[info exists cfg($key)]} {
            dict set configDict $key $cfg($key)
        } else {
            dict set configDict $key ""
        }
    }
    if {![info exists cfg(disks)]} { set cfg(disks) {} }
    if {![info exists cfg(net)]} { set cfg(net) {} }
    dict set configDict disks $cfg(disks)
    dict set configDict net $cfg(net)
    if {$mode eq "new"} {
        set id [sanitizeId [dict get $configDict name]]
    }
    saveVm $id $configDict
    loadAll
    refreshVmList
    destroy $win
}

proc ::qemu::deleteVm {id} {
    variable storageDir
    if {$id eq ""} { return }
    set path [file join $storageDir "${id}.tcl"]
    if {[file exists $path]} {
        file delete $path
    }
    loadAll
    refreshVmList
}

proc ::qemu::refreshVmList {} {
    variable vmList
    .main.list delete [.main.list children {}]
    foreach vm $vmList {
        lassign $vm id cfg
        set summary [renderVmSummary $cfg]
        .main.list insert "" end -id $id -values [list [dict get $cfg name] [dict get $cfg arch] [dict get $cfg cpus] [dict get $cfg memory] [dict get $cfg accel] [dict get $cfg display]]
    }
    ::qemu::renderDetails ""
}

proc ::qemu::selectVm {} {
    variable vmList
    variable selectedVm
    set sel [.main.list selection]
    if {$sel eq ""} {
        set selectedVm ""
        ::qemu::renderDetails ""
        return
    }
    set selectedVm [lindex $sel 0]
    ::qemu::renderDetails $selectedVm
}

proc ::qemu::getVmById {id} {
    variable vmList
    foreach vm $vmList {
        if {[lindex $vm 0] eq $id} {
            return [lindex $vm 1]
        }
    }
    return ""
}

proc ::qemu::renderDetails {id} {
    if {![winfo exists .main.detail.text]} { return }
    set txt .main.detail.text
    $txt configure -state normal
    $txt delete 1.0 end
    if {$id eq ""} {
        $txt insert end "Vyberte VM pro zobrazení detailů."
        $txt configure -state disabled
        return
    }
    set cfg [::qemu::getVmById $id]
    if {$cfg eq ""} {
        $txt insert end "Konfigurace nenalezena."
        $txt configure -state disabled
        return
    }
    $txt insert end "[dict get $cfg name]\n"
    $txt insert end "Arch: [dict get $cfg arch]\n"
    $txt insert end "Machine: [dict get $cfg machine]\n"
    $txt insert end "CPU: [dict get $cfg cpus], Model: [dict get $cfg cpu_model], Accel: [dict get $cfg accel]\n"
    $txt insert end "RAM: [dict get $cfg memory] MB\n"
    $txt insert end "Boot order: [dict get $cfg boot_order]\n"
    if {[dict get $cfg firmware] ne ""} {
        $txt insert end "Firmware: [dict get $cfg firmware]\n"
    }
    if {[dict get $cfg iso] ne ""} {
        $txt insert end "ISO: [dict get $cfg iso]\n"
    }
    if {[dict get $cfg disks] ne {}} {
        $txt insert end "Disky:\n"
        foreach d [dict get $cfg disks] {
            dict with d {
                $txt insert end "  - $media $file ($format, $if) boot:$boot ro:$readonly\n"
            }
        }
    }
    if {[dict get $cfg net] ne {}} {
        $txt insert end "Síť:\n"
        foreach n [dict get $cfg net] {
            dict with n {
                $txt insert end "  - $type $model hostfwd:$hostfwd br:$br tap:$tap mac:$mac\n"
            }
        }
    }
    set cmd [join [buildCommand $cfg] " "]
    $txt insert end "\nPříkaz:\n$cmd\n"
    $txt configure -state disabled
}

proc ::qemu::recordJobLog {status code message} {
    variable jobLogs
    set entry [dict create \
        timestamp [clock format [clock seconds] -format {%Y-%m-%d %H:%M:%S}] \
        status $status \
        code $code \
        message $message \
    ]
    lappend jobLogs $entry
}

proc ::qemu::logMatchesFilter {log} {
    variable logFilterStatus
    variable logFilterCode
    set status [expr {[dict exists $log status] ? [dict get $log status] : ""}]
    set code [expr {[dict exists $log code] ? [dict get $log code] : ""}]
    set statusOk [expr {$logFilterStatus eq "all" || $status eq $logFilterStatus}]
    set codeFilter [string trim $logFilterCode]
    set codeOk [expr {$codeFilter eq "" || [string match "*$codeFilter*" $code]}]
    return [expr {$statusOk && $codeOk}]
}

proc ::qemu::getFilteredLogs {} {
    variable jobLogs
    set result {}
    foreach log $jobLogs {
        if {[::qemu::logMatchesFilter $log]} {
            lappend result $log
        }
    }
    return $result
}

proc ::qemu::appendLogLine {textWidget log} {
    set ts [expr {[dict exists $log timestamp] ? [dict get $log timestamp] : ""}]
    set status [expr {[dict exists $log status] ? [dict get $log status] : ""}]
    set code [expr {[dict exists $log code] ? [dict get $log code] : ""}]
    set message [expr {[dict exists $log message] ? [dict get $log message] : ""}]
    $textWidget configure -state normal
    $textWidget insert end "$ts [$status/$code] $message\n"
    $textWidget see end
    $textWidget configure -state disabled
}

proc ::qemu::renderLogs {textWidget} {
    ::qemu::stopLogPlayback
    $textWidget configure -state normal
    $textWidget delete 1.0 end
    foreach log [::qemu::getFilteredLogs] {
        ::qemu::appendLogLine $textWidget $log
    }
    $textWidget see end
    $textWidget configure -state disabled
}

proc ::qemu::stopLogPlayback {} {
    variable logPlaybackAfter
    if {$logPlaybackAfter ne ""} {
        after cancel $logPlaybackAfter
        set logPlaybackAfter ""
    }
}

proc ::qemu::playbackStep {textWidget} {
    variable logPlaybackQueue
    variable logPlaybackIndex
    variable logPlaybackAfter
    if {$logPlaybackIndex >= [llength $logPlaybackQueue]} {
        set logPlaybackAfter ""
        return
    }
    set log [lindex $logPlaybackQueue $logPlaybackIndex]
    incr logPlaybackIndex
    ::qemu::appendLogLine $textWidget $log
    set logPlaybackAfter [after 400 [list ::qemu::playbackStep $textWidget]]
}

proc ::qemu::startLogPlayback {textWidget} {
    variable logPlaybackQueue
    variable logPlaybackIndex
    ::qemu::stopLogPlayback
    set logPlaybackQueue [::qemu::getFilteredLogs]
    set logPlaybackIndex 0
    $textWidget configure -state normal
    $textWidget delete 1.0 end
    $textWidget configure -state disabled
    ::qemu::playbackStep $textWidget
}

proc ::qemu::clearLogs {textWidget} {
    variable jobLogs
    set jobLogs {}
    ::qemu::stopLogPlayback
    $textWidget configure -state normal
    $textWidget delete 1.0 end
    $textWidget configure -state disabled
}

proc ::qemu::openLogViewer {} {
    variable logViewerText
    variable logFilterStatus
    variable logFilterCode
    if {[winfo exists .logviewer]} {
        raise .logviewer
        focus .logviewer
        return
    }
    set win [toplevel .logviewer]
    wm title $win "Job logy"

    bind $win <Destroy> {::qemu::stopLogPlayback; set ::qemu::logViewerText ""}

    ttk::frame $win.filters -padding 4
    ttk::label $win.filters.statusL -text "Status"
    ttk::combobox $win.filters.status -values {all queued running completed failed} \
        -textvariable ::qemu::logFilterStatus -state readonly -width 12
    ttk::label $win.filters.codeL -text "Kód"
    ttk::entry $win.filters.code -textvariable ::qemu::logFilterCode -width 12
    ttk::button $win.filters.apply -text "Filtrovat" -command [list ::qemu::renderLogs $win.text]
    grid $win.filters.statusL -row 0 -column 0 -padx 3 -pady 2
    grid $win.filters.status -row 0 -column 1 -padx 3 -pady 2
    grid $win.filters.codeL -row 0 -column 2 -padx 3 -pady 2
    grid $win.filters.code -row 0 -column 3 -padx 3 -pady 2
    grid $win.filters.apply -row 0 -column 4 -padx 3 -pady 2
    grid columnconfigure $win.filters 1 -weight 1
    grid $win.filters -row 0 -column 0 -columnspan 2 -sticky we

    ttk::frame $win.actions -padding 4
    ttk::button $win.actions.play -text "Přehrát" -command [list ::qemu::startLogPlayback $win.text]
    ttk::button $win.actions.stop -text "Stop" -command ::qemu::stopLogPlayback
    ttk::button $win.actions.clear -text "Clear" -command [list ::qemu::clearLogs $win.text]
    ttk::button $win.actions.close -text "Zavřít" -command [list destroy $win]
    grid $win.actions.play -row 0 -column 0 -padx 3 -pady 2
    grid $win.actions.stop -row 0 -column 1 -padx 3 -pady 2
    grid $win.actions.clear -row 0 -column 2 -padx 3 -pady 2
    grid $win.actions.close -row 0 -column 3 -padx 3 -pady 2
    grid $win.actions -row 1 -column 0 -columnspan 2 -sticky we

    text $win.text -wrap word -width 100 -height 20 -state disabled -yscrollcommand "$win.scroll set"
    ttk::scrollbar $win.scroll -orient vertical -command "$win.text yview"
    grid $win.text -row 2 -column 0 -sticky news
    grid $win.scroll -row 2 -column 1 -sticky ns
    grid rowconfigure $win 2 -weight 1
    grid columnconfigure $win 0 -weight 1

    bind $win.filters.status <<ComboboxSelected>> [list ::qemu::renderLogs $win.text]
    bind $win.filters.code <KeyRelease> [list ::qemu::renderLogs $win.text]

    set logViewerText $win.text
    ::qemu::renderLogs $win.text
}

proc ::qemu::openSettingsDialog {} {
    variable qemuPathOverrides
    set win [toplevel .settings]
    wm title $win "Cesty k QEMU binárkám"
    set row 0
    foreach arch {x86_64 i386 aarch64 arm} {
        ttk::label $win.l$row -text "qemu-system-$arch"
        ttk::entry $win.e$row -textvariable ::qemu::qemuPathOverrides($arch)
        grid $win.l$row -row $row -column 0 -sticky w -padx 4 -pady 2
        grid $win.e$row -row $row -column 1 -sticky we -padx 4 -pady 2
        incr row
    }
    ttk::button $win.close -text "Zavřít" -command [list destroy $win]
    grid $win.close -row $row -column 0 -columnspan 2 -pady 6
    grid columnconfigure $win 1 -weight 1
}

proc ::qemu::mainUi {} {
    ensureStorage
    loadAll
    ttk::frame .main -padding 6
    pack .main -fill both -expand 1
    ttk::label .main.title -text "QEMU Správce VM" -font "TkDefaultFont 12 bold"
    pack .main.title -anchor w -pady 4

    ttk::frame .main.toolbar
    ttk::button .main.toolbar.new -text "Nový" -command [list ::qemu::openVmForm new]
    ttk::button .main.toolbar.edit -text "Upravit" -command {
        set sel [.main.list selection]
        if {$sel eq ""} { return }
        set vm [::qemu::getVmById [lindex $sel 0]]
        ::qemu::openVmForm edit [lindex $sel 0] $vm
    }
    ttk::button .main.toolbar.del -text "Smazat" -command {
        set sel [.main.list selection]
        if {$sel eq ""} { return }
        set vm [::qemu::getVmById [lindex $sel 0]]
        if {[tk_messageBox -type yesno -icon question -title "Smazat VM" \
            -message "Opravdu smazat VM [dict get $vm name]?"] eq "yes"} {
            ::qemu::deleteVm [lindex $sel 0]
        }
    }
    ttk::button .main.toolbar.start -text "Start" -command {
        set sel [.main.list selection]
        if {$sel eq ""} { return }
        set vm [::qemu::getVmById [lindex $sel 0]]
        ::qemu::startVm $vm
    }
    ttk::button .main.toolbar.cmd -text "Příkaz" -command {
        set sel [.main.list selection]
        if {$sel eq ""} { return }
        set vm [::qemu::getVmById [lindex $sel 0]]
        ::qemu::showCommand $vm
    }
    ttk::button .main.toolbar.logs -text "Logy" -command ::qemu::openLogViewer
    ttk::button .main.toolbar.settings -text "Nastavení QEMU cest" -command ::qemu::openSettingsDialog
    pack .main.toolbar.new .main.toolbar.edit .main.toolbar.del \
        .main.toolbar.start .main.toolbar.cmd .main.toolbar.logs .main.toolbar.settings \
        -side left -padx 3
    pack .main.toolbar -fill x -pady 4

    ttk::panedwindow .main.pw -orient vertical
    pack .main.pw -fill both -expand 1

    ttk::frame .main.listFrame
    set tree [ttk::treeview .main.list -columns {name arch cpu ram accel display} -show headings -selectmode browse]
    .main.list heading name -text "Název"
    .main.list heading arch -text "Arch"
    .main.list heading cpu -text "CPU"
    .main.list heading ram -text "RAM (MB)"
    .main.list heading accel -text "Accel"
    .main.list heading display -text "Display"
    .main.list column name -width 180
    .main.list column arch -width 70
    .main.list column cpu -width 60
    .main.list column ram -width 90
    .main.list column accel -width 90
    .main.list column display -width 90
    bind .main.list <<TreeviewSelect>> ::qemu::selectVm
    pack .main.list -fill both -expand 1
    .main.pw add .main.list -weight 3

    ttk::frame .main.detail
    ttk::label .main.detail.label -text "Detaily VM"
    text .main.detail.text -height 8 -wrap word -state disabled
    pack .main.detail.label -anchor w
    pack .main.detail.text -fill both -expand 1
    .main.pw add .main.detail -weight 2

    refreshVmList
}

::qemu::mainUi
