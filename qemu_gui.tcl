#!/usr/bin/env tclsh
##
## Multiplatform Tcl/Tk GUI for configuring and launching QEMU virtual machines.
## The tool manages simple per-VM configuration files and can generate or run
## QEMU command lines based on the options described in readme.md.
##

package require Tcl 8.6
if {[catch {package require Tk} err]} {
    puts "Tk is required to run this GUI: $err"
    exit 1
}

namespace eval ::qemu {
    variable appVersion "0.1"
    variable storageDir [file normalize [file join [pwd] "vms"]]
    variable vmList {}
    variable selectedVm ""
    variable qemuPathOverrides {
        x86_64 ""
        i386 ""
        aarch64 ""
        arm ""
    }
}

proc ::qemu::ensureStorage {} {
    variable storageDir
    if {![file exists $storageDir]} {
        file mkdir $storageDir
    }
}

proc ::qemu::sanitizeId {name} {
    set base [string map {{ } _} [string tolower $name]]
    regsub -all {[^a-zA-Z0-9_.-]} $base "_" base
    if {$base eq ""} { set base "vm" }
    set id "${base}_[clock format [clock seconds] -format %Y%m%d%H%M%S]"
    return $id
}

proc ::qemu::loadVmFile {path} {
    set config {}
    if {[catch {source $path} err]} {
        tk_messageBox -icon error -type ok -title "Chyba při načítání" \
            -message "Konfigurace $path nelze načíst:\n$err"
        return ""
    }
    if {![info exists config]} {
        return ""
    }
    return $config
}

proc ::qemu::loadAll {} {
    variable storageDir
    variable vmList
    set vmList {}
    foreach f [lsort [glob -nocomplain -types f [file join $storageDir "*.tcl"]]] {
        set cfg [loadVmFile $f]
        if {$cfg eq ""} { continue }
        set id [file rootname [file tail $f]]
        lappend vmList [list $id $cfg]
    }
}

proc ::qemu::saveVm {id config} {
    variable storageDir
    set path [file join $storageDir "${id}.tcl"]
    set fh [open $path w]
    puts $fh "# Autogenerated VM config"
    puts $fh "set config [list $config]"
    close $fh
}

proc ::qemu::renderVmSummary {cfg} {
    set name [dict get $cfg name]
    set arch [dict get $cfg arch]
    set mem [dict get $cfg memory]
    set cpus [dict get $cfg cpus]
    set machine [dict get $cfg machine]
    set accel [dict get $cfg accel]
    set display [dict get $cfg display]
    return "$name — $arch, ${cpus}CPU, ${mem}MB, machine $machine, accel $accel, display $display"
}

proc ::qemu::getDefaultConfig {} {
    return [dict create \
        name "New VM" \
        arch "x86_64" \
        machine "pc" \
        memory 2048 \
        cpus 2 \
        cpu_model "host" \
        accel "kvm" \
        boot_order "cd" \
        firmware "" \
        iso "" \
        vga "std" \
        display "sdl" \
        snapshot_mode 0 \
        extra_args "" \
        disks {} \
        net {} \
    ]
}

proc ::qemu::addDiskToConfig {cfg diskDict} {
    set disks [dict get $cfg disks]
    lappend disks $diskDict
    dict set cfg disks $disks
    return $cfg
}

proc ::qemu::addNetToConfig {cfg netDict} {
    set nets [dict get $cfg net]
    lappend nets $netDict
    dict set cfg net $nets
    return $cfg
}

proc ::qemu::buildQemuBinary {arch} {
    variable qemuPathOverrides
    set override [dict get $qemuPathOverrides $arch]
    if {$override ne ""} {
        return $override
    }
    switch -- $arch {
        x86_64 { return "qemu-system-x86_64" }
        i386 { return "qemu-system-i386" }
        aarch64 { return "qemu-system-aarch64" }
        arm { return "qemu-system-arm" }
        default { return "qemu-system-$arch" }
    }
}

proc ::qemu::buildCommand {cfg} {
    set arch [dict get $cfg arch]
    set cmd [list [buildQemuBinary $arch]]
    dict with cfg {
        if {$name ne ""} { lappend cmd -name $name }
        if {$machine ne ""} { lappend cmd -machine $machine }
        if {$accel ne ""} { lappend cmd -accel $accel }
        if {$cpu_model ne ""} { lappend cmd -cpu $cpu_model }
        if {$cpus ne ""} { lappend cmd -smp $cpus }
        if {$memory ne ""} { lappend cmd -m $memory }
        if {$boot_order ne ""} { lappend cmd -boot "order=$boot_order" }
        if {$firmware ne ""} { lappend cmd -bios $firmware }
        if {$snapshot_mode} { lappend cmd -snapshot }
        if {$vga ne ""} { lappend cmd -vga $vga }
        if {$display ne ""} { lappend cmd -display $display }
    }
    foreach disk [dict get $cfg disks] {
        dict with disk {
            if {$media eq "cdrom"} {
                lappend cmd -drive "file=$file,format=$format,if=$if,media=cdrom"
            } else {
                set readonlyFlag ""
                if {$readonly} { set readonlyFlag ",snapshot=on" }
                lappend cmd -drive "file=$file,format=$format,if=$if,media=disk$readonlyFlag"
            }
            if {$boot} {
                # crude boot order hint: place bootable CD before disks
            }
        }
    }
    set iso [dict get $cfg iso]
    if {$iso ne ""} {
        lappend cmd -cdrom $iso
    }
    foreach net [dict get $cfg net] {
        dict with net {
            set nic "type=$type"
            if {$model ne ""} { append nic ",model=$model" }
            if {$hostfwd ne ""} { append nic ",hostfwd=$hostfwd" }
            if {$br ne ""} { append nic ",br=$br" }
            if {$tap ne ""} { append nic ",ifname=$tap" }
            if {$mac ne ""} { append nic ",mac=$mac" }
            lappend cmd -nic $nic
        }
    }
    set extra [dict get $cfg extra_args]
    if {$extra ne ""} {
        foreach token $extra { lappend cmd $token }
    }
    return $cmd
}

proc ::qemu::startVm {cfg} {
    set cmd [buildCommand $cfg]
    set commandStr [join $cmd " "]
    set res [tk_messageBox -type yesno -icon question -title "Spustit VM" \
        -message "Spustit následující příkaz?\n$commandStr"]
    if {$res ne "yes"} { return }
    if {[catch {eval exec {*}$cmd &} err]} {
        tk_messageBox -icon error -type ok -title "Spuštění selhalo" \
            -message "Příkaz se nepodařilo spustit:\n$err"
    }
}

proc ::qemu::showCommand {cfg} {
    set cmd [buildCommand $cfg]
    set win [toplevel .cmd]
    wm title $win "Vygenerovaný příkaz"
    text $win.t -wrap word -width 80 -height 8
    $win.t insert end [join $cmd " "]
    $win.t configure -state disabled
    pack $win.t -fill both -expand 1
}

proc ::qemu::openVmForm {mode {id ""} {cfg ""}} {
    if {$cfg eq ""} {
        set cfg [getDefaultConfig]
    }
    set varName "::qemu::form_[string map {. _} [clock clicks]]"

    set win [toplevel .vmform]
    wm title $win [expr {$mode eq "edit" ? "Upravit VM" : "Nový VM"}]

    set row 0
    foreach {label key default} {
        "Název" name {}
        "Architektura" arch {}
        "Machine" machine {}
        "RAM (MB)" memory {}
        "CPU (počet)" cpus {}
        "Model CPU" cpu_model {}
        "Akcelerace" accel {}
        "Firmware/BIOS" firmware {}
        "Boot order" boot_order {}
        "ISO (CD/DVD)" iso {}
        "VGA" vga {}
        "Display" display {}
    } {
        ttk::label $win.l$row -text $label
        ttk::entry $win.e$row -textvariable ${varName}($key)
        grid $win.l$row -row $row -column 0 -sticky w -padx 4 -pady 2
        grid $win.e$row -row $row -column 1 -sticky we -padx 4 -pady 2
        incr row
    }

    ttk::checkbutton $win.snapshot -text "Spustit v režimu snapshot (-snapshot)" \
        -variable ${varName}(snapshot_mode)
    grid $win.snapshot -row $row -column 0 -columnspan 2 -sticky w -padx 4 -pady 2
    incr row

    ttk::label $win.extraL -text "Dodatečné parametry (oddělené mezerou)"
    ttk::entry $win.extraE -textvariable ${varName}(extra_args)
    grid $win.extraL -row $row -column 0 -sticky w -padx 4 -pady 2
    grid $win.extraE -row $row -column 1 -sticky we -padx 4 -pady 2
    incr row

    # Disks
    ttk::label $win.diskL -text "Disky / CD"
    listbox $win.disks -height 5
    ttk::frame $win.diskBtns
    ttk::button $win.diskBtns.add -text "Přidat" -command [list ::qemu::addDiskDialog $win $varName]
    ttk::button $win.diskBtns.del -text "Odebrat" -command [list ::qemu::removeSelectedDisk $win $varName]
    pack $win.diskBtns.add $win.diskBtns.del -side left -padx 2
    grid $win.diskL -row $row -column 0 -sticky nw -padx 4 -pady 2
    grid $win.disks -row $row -column 1 -sticky we -padx 4 -pady 2
    grid $win.diskBtns -row $row -column 2 -sticky w
    incr row

    # Network
    ttk::label $win.netL -text "Síťová rozhraní"
    listbox $win.nets -height 4
    ttk::frame $win.netBtns
    ttk::button $win.netBtns.add -text "Přidat" -command [list ::qemu::addNetDialog $win $varName]
    ttk::button $win.netBtns.del -text "Odebrat" -command [list ::qemu::removeSelectedNet $win $varName]
    pack $win.netBtns.add $win.netBtns.del -side left -padx 2
    grid $win.netL -row $row -column 0 -sticky nw -padx 4 -pady 2
    grid $win.nets -row $row -column 1 -sticky we -padx 4 -pady 2
    grid $win.netBtns -row $row -column 2 -sticky w
    incr row

    ttk::frame $win.actions
    ttk::button $win.actions.ok -text "Uložit" -command [list ::qemu::saveVmFromForm $win $mode $id $varName]
    ttk::button $win.actions.cancel -text "Zavřít" -command [list destroy $win]
    pack $win.actions.ok $win.actions.cancel -side left -padx 4 -pady 4
    grid $win.actions -row $row -column 0 -columnspan 3

    # Populate entries with cfg dict via array
    array set $varName $cfg
    if {![info exists ${varName}(disks)]} { set ${varName}(disks) {} }
    if {![info exists ${varName}(net)]} { set ${varName}(net) {} }
    ::qemu::refreshDiskList $win $varName
    ::qemu::refreshNetList $win $varName

    grid columnconfigure $win 1 -weight 1
}

proc ::qemu::addDiskDialog {parent cfgVar} {
    set win [toplevel $parent.diskDialog]
    wm title $win "Přidat disk"
    set row 0
    foreach {label key default} {
        "Soubor" file ""
        "Formát" format "qcow2"
        "Rozhraní" if "virtio"
        "Typ média (disk/cdrom)" media "disk"
        "Bootovací (1/0)" boot 0
        "Pouze čtení (1/0)" readonly 0
    } {
        ttk::label $win.l$row -text $label
        ttk::entry $win.e$row -textvariable disk($key)
        grid $win.l$row -row $row -column 0 -sticky w -padx 4 -pady 2
        grid $win.e$row -row $row -column 1 -sticky we -padx 4 -pady 2
        incr row
    }
    ttk::frame $win.actions
    ttk::button $win.actions.ok -text "Přidat" -command [list ::qemu::confirmAddDisk $win $parent $cfgVar]
    ttk::button $win.actions.cancel -text "Zrušit" -command [list destroy $win]
    pack $win.actions.ok $win.actions.cancel -side left -padx 4 -pady 4
    grid $win.actions -row $row -column 0 -columnspan 2
    grid columnconfigure $win 1 -weight 1
}

proc ::qemu::confirmAddDisk {win parent cfgVar} {
    upvar $cfgVar cfg
    upvar $win::disk disk
    if {![info exists disk(file)] || $disk(file) eq ""} {
        tk_messageBox -icon warning -type ok -title "Chybí soubor" \
            -message "Zadejte cestu k souboru disku."
        return
    }
    set diskDict [dict create \
        file $disk(file) \
        format [expr {[info exists disk(format)] ? $disk(format) : "qcow2"}] \
        if [expr {[info exists disk(if)] ? $disk(if) : "virtio"}] \
        media [expr {[info exists disk(media)] ? $disk(media) : "disk"}] \
        boot [expr {[info exists disk(boot)] ? $disk(boot) : 0}] \
        readonly [expr {[info exists disk(readonly)] ? $disk(readonly) : 0}] \
    ]
    set disks $cfg(disks)
    lappend disks $diskDict
    set cfg(disks) $disks
    ::qemu::refreshDiskList $parent $cfgVar
    destroy $win
}

proc ::qemu::refreshDiskList {parent cfgVar} {
    upvar $cfgVar cfg
    $parent.disks delete 0 end
    foreach disk $cfg(disks) {
        dict with disk {
            $parent.disks insert end "$media: $file ($format, $if) [boot:$boot ro:$readonly]"
        }
    }
}

proc ::qemu::removeSelectedDisk {parent cfgVar} {
    upvar $cfgVar cfg
    set sel [$parent.disks curselection]
    if {$sel eq ""} { return }
    set disks $cfg(disks)
    set keep {}
    set i 0
    foreach disk $disks {
        if {[lsearch -exact $sel $i] == -1} {
            lappend keep $disk
        }
        incr i
    }
    set cfg(disks) $keep
    ::qemu::refreshDiskList $parent $cfgVar
}

proc ::qemu::addNetDialog {parent cfgVar} {
    set win [toplevel $parent.netDialog]
    wm title $win "Přidat síť"
    set row 0
    foreach {label key default} {
        "Typ (user/bridge/tap/none)" type "user"
        "Model" model "virtio-net-pci"
        "Hostfwd (např. tcp::2222-:22)" hostfwd ""
        "Bridge jméno" br ""
        "TAP jméno" tap ""
        "MAC adresa" mac ""
    } {
        ttk::label $win.l$row -text $label
        ttk::entry $win.e$row -textvariable net($key)
        grid $win.l$row -row $row -column 0 -sticky w -padx 4 -pady 2
        grid $win.e$row -row $row -column 1 -sticky we -padx 4 -pady 2
        incr row
    }
    ttk::frame $win.actions
    ttk::button $win.actions.ok -text "Přidat" -command [list ::qemu::confirmAddNet $win $parent $cfgVar]
    ttk::button $win.actions.cancel -text "Zrušit" -command [list destroy $win]
    pack $win.actions.ok $win.actions.cancel -side left -padx 4 -pady 4
    grid $win.actions -row $row -column 0 -columnspan 2
    grid columnconfigure $win 1 -weight 1
}

proc ::qemu::confirmAddNet {win parent cfgVar} {
    upvar $cfgVar cfg
    upvar $win::net net
    set netDict [dict create \
        type [expr {[info exists net(type)] ? $net(type) : "user"}] \
        model [expr {[info exists net(model)] ? $net(model) : "virtio-net-pci"}] \
        hostfwd [expr {[info exists net(hostfwd)] ? $net(hostfwd) : ""}] \
        br [expr {[info exists net(br)] ? $net(br) : ""}] \
        tap [expr {[info exists net(tap)] ? $net(tap) : ""}] \
        mac [expr {[info exists net(mac)] ? $net(mac) : ""}] \
    ]
    set nets $cfg(net)
    lappend nets $netDict
    set cfg(net) $nets
    ::qemu::refreshNetList $parent $cfgVar
    destroy $win
}

proc ::qemu::refreshNetList {parent cfgVar} {
    upvar $cfgVar cfg
    $parent.nets delete 0 end
    foreach net $cfg(net) {
        dict with net {
            $parent.nets insert end "$type/$model hostfwd:$hostfwd br:$br tap:$tap mac:$mac"
        }
    }
}

proc ::qemu::removeSelectedNet {parent cfgVar} {
    upvar $cfgVar cfg
    set sel [$parent.nets curselection]
    if {$sel eq ""} { return }
    set nets $cfg(net)
    set keep {}
    set i 0
    foreach net $nets {
        if {[lsearch -exact $sel $i] == -1} {
            lappend keep $net
        }
        incr i
    }
    set cfg(net) $keep
    ::qemu::refreshNetList $parent $cfgVar
}

proc ::qemu::saveVmFromForm {win mode id cfgVar} {
    upvar $cfgVar cfg
    set configDict [dict create]
    foreach key {
        name arch machine memory cpus cpu_model accel firmware boot_order iso
        vga display snapshot_mode extra_args
    } {
        if {[info exists cfg($key)]} {
            dict set configDict $key $cfg($key)
        } else {
            dict set configDict $key ""
        }
    }
    if {![info exists cfg(disks)]} { set cfg(disks) {} }
    if {![info exists cfg(net)]} { set cfg(net) {} }
    dict set configDict disks $cfg(disks)
    dict set configDict net $cfg(net)
    if {$mode eq "new"} {
        set id [sanitizeId [dict get $configDict name]]
    }
    saveVm $id $configDict
    loadAll
    refreshVmList
    destroy $win
}

proc ::qemu::deleteVm {id} {
    variable storageDir
    if {$id eq ""} { return }
    set path [file join $storageDir "${id}.tcl"]
    if {[file exists $path]} {
        file delete $path
    }
    loadAll
    refreshVmList
}

proc ::qemu::refreshVmList {} {
    variable vmList
    .main.list delete 0 end
    foreach vm $vmList {
        lassign $vm id cfg
        set summary [renderVmSummary $cfg]
        .main.list insert end "$id — $summary"
    }
}

proc ::qemu::selectVm {} {
    variable vmList
    variable selectedVm
    set idx [.main.list curselection]
    if {$idx eq ""} { set selectedVm ""; return }
    set selectedVm [lindex [lindex $vmList $idx] 0]
}

proc ::qemu::getVmById {id} {
    variable vmList
    foreach vm $vmList {
        if {[lindex $vm 0] eq $id} {
            return [lindex $vm 1]
        }
    }
    return ""
}

proc ::qemu::openSettingsDialog {} {
    variable qemuPathOverrides
    set win [toplevel .settings]
    wm title $win "Cesty k QEMU binárkám"
    set row 0
    foreach arch {x86_64 i386 aarch64 arm} {
        ttk::label $win.l$row -text "qemu-system-$arch"
        ttk::entry $win.e$row -textvariable ::qemu::qemuPathOverrides($arch)
        grid $win.l$row -row $row -column 0 -sticky w -padx 4 -pady 2
        grid $win.e$row -row $row -column 1 -sticky we -padx 4 -pady 2
        incr row
    }
    ttk::button $win.close -text "Zavřít" -command [list destroy $win]
    grid $win.close -row $row -column 0 -columnspan 2 -pady 6
    grid columnconfigure $win 1 -weight 1
}

proc ::qemu::mainUi {} {
    ensureStorage
    loadAll
    ttk::frame .main
    pack .main -fill both -expand 1
    ttk::label .main.title -text "QEMU GUI (Tcl/Tk)" -font "TkDefaultFont 12 bold"
    listbox .main.list -height 10 -exportselection 0
    bind .main.list <<ListboxSelect>> ::qemu::selectVm
    ttk::frame .main.buttons
    ttk::button .main.buttons.new -text "Nový" -command [list ::qemu::openVmForm new]
    ttk::button .main.buttons.edit -text "Upravit" -command {
        set idx [.main.list curselection]
        if {$idx eq ""} { return }
        set vm [lindex $::qemu::vmList $idx]
        ::qemu::openVmForm edit [lindex $vm 0] [lindex $vm 1]
    }
    ttk::button .main.buttons.del -text "Smazat" -command {
        set idx [.main.list curselection]
        if {$idx eq ""} { return }
        set vm [lindex $::qemu::vmList $idx]
        if {[tk_messageBox -type yesno -icon question -title "Smazat VM" \
            -message "Opravdu smazat VM [dict get [lindex $vm 1] name]?"] eq "yes"} {
            ::qemu::deleteVm [lindex $vm 0]
        }
    }
    ttk::button .main.buttons.cmd -text "Zobrazit příkaz" -command {
        set idx [.main.list curselection]
        if {$idx eq ""} { return }
        set vm [lindex $::qemu::vmList $idx]
        ::qemu::showCommand [lindex $vm 1]
    }
    ttk::button .main.buttons.start -text "Start" -command {
        set idx [.main.list curselection]
        if {$idx eq ""} { return }
        set vm [lindex $::qemu::vmList $idx]
        ::qemu::startVm [lindex $vm 1]
    }
    ttk::button .main.buttons.settings -text "Nastavení QEMU cest" -command ::qemu::openSettingsDialog
    pack .main.buttons.new .main.buttons.edit .main.buttons.del \
        .main.buttons.cmd .main.buttons.start .main.buttons.settings \
        -side left -padx 3 -pady 4
    pack .main.title -anchor w -padx 6 -pady 4
    pack .main.list -fill both -expand 1 -padx 6
    pack .main.buttons -anchor w -padx 6 -pady 6

    refreshVmList
}

::qemu::mainUi
